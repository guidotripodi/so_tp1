
\subsubsection{Introduccion}

\subsubsection{Ejercicios}
\begin{itemize}
 \item 
\textbf{Ejercicio 3}  Completar la implementacion del scheduler Round-Robin implementando los
metodos de la clase SchedRR en los archivos sched rr.cpp y sched rr.h. La implementacion
recibe como primer parametro la cantidad de nucleos y a continuacion los valores de sus
respectivos quantums. Debe utilizar una unica cola global, permitiendo ası la migracion de
procesos entre nucleos.
\item \textbf{Ejercicio 4} Diseñar uno o mas lotes de tareas para ejecutar con el algoritmo del ejercicio
anterior. Graficar las simulaciones y comentarlas, justificando brevemente por que el comportamiento 
observado es efectivamente el esperable de un algoritmo Round-Robin.
\item \textbf{Ejercicio 5} A partir del artıculo
Waldspurger, C.A. and Weihl, W.E., Lottery scheduling: Flexible proportional-share re-
source management. Proceedings of the 1st USENIX conference on Operating Systems
Design and Implementation – 1994.
diseñar e implementar un scheduler basado en el esquema de loterıa. El constructor de la
clase SchedLottery debe recibir dos parametros: el quantum y la semilla de la secuencia
pseudoaleatoria (en ese orden). Interesa implementar al menos la idea basica del algoritmo
y la optimizacion de tickets compensatorios (compensation tickets). Otras optimizaciones y
refinamientos que propone el artıculo seran opcionales siempre que, en cada caso, se explique
brevemente por que la optimizacion no se considero relevante a los efectos de este trabajo.

\end{itemize}


\subsubsection{Resultados y Conclusiones}

\subsection[]{Ejercicio 3}

\indent \indent Requerido por la consigna, completamos la implementación del scheduler Round-Robin. Para simular su comportamiento de manera correcta, hicimos uso de diversas estructuras de datos cuya composición y uso describimos a continuación.\\
\begin{itemize}
\item Una cola global FIFO nombrada $tareas$, que contiene los pid de las tareas activas no bloqueadas y cuyo tope representa a la próxima tarea a correr. Utilizar una cola FIFO nos permite modelar el comportamiento deseado, puesto que al desalojarse una tarea por consumir su quantum será agregada nuevamente a la cola, quedando así al final de ésta y generando el accionar cíclico que buscamos. Al ser además la única cola para todos los cores, no se restringe a una tarea a ser ejecutada por un único núcleo, permitiendo así la migración entre cores.\\
\item El vector $cores$ contiene en su elemento $i$ y el pid correspondiente a la tarea que está corriendo en el core $i+1$. Inicializamos todos sus elementos en $-1$ (que se corresponde con la Idle Task) para reconocer que no se han cargado tareas en los núcleos de procesamiento.\\
\item De la misma manera, el vector $quantum$ contiene en la posición $i$ el quantum definido para el núcleo $i+1$ y el vector $ticks$, cuántos ticks ha pasado desde que se cargó la tarea en el core. En conjunto, ambas estructuras nos permiten determinar cuándo se consumió el quantum de una tarea, de manera tal que podamos desalojarla.\\
\end{itemize}
\indent \indent Finalmente, un pequeño comentario sobre nuestra implementación.\\
%\indent Al inicio, las tareas se asignan siguiendo el orden numérico de los núcleos. Esto es, la primer tarea en llegar será alojada en el core 0 y así sucesivamente. Asimismo, si una tarea bloqueada se desbloquea, se asigna a un core de la misma manera que si llegase por primera vez (si encuentra un core libre se la asigna a éste o caso contrario se la envía a la cola $tareas$).\\
\indent \indent Como dato anecdótico, que además nos sirve para justificar la implementación del $load$, en nuestra primera implementación del algoritmo al momento de cargar una tarea, la asignábamos a un core siguiendo el orden numérico de los núcleos. Es decir, se la asignaba al primer núcleo que encontraba vacío (o corriendo la tarea IDLE). Si no encontraba ningún núcleo libre, se la enviaba la cola de tareas. Sin embargo, al comenzar a experimentar descubrimos que esta implementación no funcionaba correctamente: para la primera corrida de la tarea, lo hacía por un tick menos que el quantum indicado. Por lo tanto, decidimos modificar la implementación, de manera que al llegar una tarea se la envíe directamente a la cola de tareas y cuando un core busque una tarea, si corresponde su turno, la correrá. Con esto pudimos solventar dicho incoveniente.\\
